# Tutorial Week 4

## Questions

### R3000 and assembly

Q1. What is a branch delay?

The pipeline structure of the MIPS CPU means that when a jump instruction reaches the "execute" phase and a new program counter is generated, the instruction after the jump will have already been decoded. Rather than discard this potentially useful work, the architecture rules state that the instruction after a branch is always executed before the instruction at the target of the branch.

Q2. The goal of this question is to have you reverse engineer some of the C compiler function calling convention (instead of reading it from a manual). The following code contains 6 functions that take 1 to 6 integer arguments. Each function sums its arguments and returns the sum as a the result.

``` C
#include <stdio.h>

/* function protoypes, would normally be in header files */
int arg1(int a);
int arg2(int a, int b);
int arg3(int a, int b, int c);
int arg4(int a, int b, int c, int d);
int arg5(int a, int b, int c, int d, int e );
int arg6(int a, int b, int c, int d, int e, int f);

/* implementations */
int arg1(int a)
{
  return a;
}

int arg2(int a, int b)
{
  return a + b;
}  

int arg3(int a, int b, int c)
{
  return a + b + c;
}

int arg4(int a, int b, int c, int d)
{
  return a + b + c + d;
}

int arg5(int a, int b, int c, int d, int e )
{
  return a + b + c + d + e;
}

int arg6(int a, int b, int c, int d, int e, int f)
{
  return a + b + c + d + e + f;
}

/* do nothing main, so we can compile it */
int main()
{
}
```

The following code is the disassembled code that is generated by the C compiler (with certain optimisations turned of for the sake of clarity).

``` assembly
004000f0 <arg1>:
  4000f0:       03e00008        jr      ra
  4000f4:       00801021        move    v0,a0

004000f8 <arg2>:
  4000f8:       03e00008        jr      ra
  4000fc:       00851021        addu    v0,a0,a1

00400100 <arg3>:
  400100:       00851021        addu    v0,a0,a1
  400104:       03e00008        jr      ra
  400108:       00461021        addu    v0,v0,a2

0040010c <arg4>:
  40010c:       00852021        addu    a0,a0,a1
  400110:       00861021        addu    v0,a0,a2
  400114:       03e00008        jr      ra
  400118:       00471021        addu    v0,v0,a3

0040011c <arg5>:
  40011c:       00852021        addu    a0,a0,a1
  400120:       00863021        addu    a2,a0,a2
  400124:       00c73821        addu    a3,a2,a3
  400128:       8fa20010        lw      v0,16(sp)
  40012c:       03e00008        jr      ra
  400130:       00e21021        addu    v0,a3,v0

00400134 <arg6>:
  400134:       00852021        addu    a0,a0,a1
  400138:       00863021        addu    a2,a0,a2
  40013c:       00c73821        addu    a3,a2,a3
  400140:       8fa20010        lw      v0,16(sp)
  400144:       00000000        nop
  400148:       00e22021        addu    a0,a3,v0
  40014c:       8fa20014        lw      v0,20(sp)
  400150:       03e00008        jr      ra
  400154:       00821021        addu    v0,a0,v0

00400158 <main>:
  400158:       03e00008        jr      ra
  40015c:       00001021        move    v0,zero
```

  a. `arg1` (and functions in general) returns its return value in what register?  
  `v0`, which contains the value of a0

  b. Why is there no stack references in `arg3`?  
  There are no **local** variables inside the function, so the compiler does not need space to store them on the stack

  c. What does `jr ra` do?  
  Jumps to address in register `ra`. `ra` is set by a `jal` instruction to the address of the instruction after `jal`. Thus function calls can be implemented with `jal` and `jr ra` instructions

  d. Which register contains the first argument to the function?  
  `a0`

  e. Why is the move instruction in `arg1` after the `jr` instruction.  
  The instruction after the jump (i.e. the instruction in the branch delay slot is executed prior to arriving at the destination of the jump. Thus, logically the `move` instruction is executed before `arg1` returns

  f. Why does `arg5` and `arg6` reference the stack?  
  Up to **4 arguments** can be passed to a function in `a[0-3]` registers. If we need to store more arguments we store them on the stack

Q3. The following code provides an example to illustrate stack management by the C compiler. Firstly, examine the C code in the provided example to understand how the recursive function works.

``` C
#include <stdio.h>
#include <unistd.h>

char teststr[] = "\nThe quick brown fox jumps of the lazy dog.\n";

void reverse_print(char *s)
{
  if (*s != '\0') {
    reverse_print(s+1);
    write(STDOUT_FILENO,s,1);
  }
}

 int main()
{
  reverse_print(teststr);
}
```

The following code is the disassembled code that is generated by the C compiler (with certain optimisations turned off for the sake of clarity).

``` assembly
004000f0 <reverse_print>:
  4000f0:       27bdffe8        addiu   sp,sp,-24
  4000f4:       afbf0014        sw      ra,20(sp)
  4000f8:       afb00010        sw      s0,16(sp)
  4000fc:       80820000        lb      v0,0(a0)
  400100:       00000000        nop
  400104:       10400007        beqz    v0,400124 <reverse_print+0x34>
  400108:       00808021        move    s0,a0
  40010c:       0c10003c        jal     4000f0 <reverse_print>
  400110:       24840001        addiu   a0,a0,1
  400114:       24040001        li      a0,1
  400118:       02002821        move    a1,s0
  40011c:       0c1000af        jal     4002bc <write>
  400120:       24060001        li      a2,1
  400124:       8fbf0014        lw      ra,20(sp)
  400128:       8fb00010        lw      s0,16(sp)
  40012c:       03e00008        jr      ra
  400130:       27bd0018        addiu   sp,sp,24
```

  a. Describe what each line in the code is doing.  

``` assembly

004000f0 <reverse_print>:
  4000f0:       27bdffe8        addiu   sp,sp,-24
  Allocate 24 bytes on the stack, 16 for a0-a3 (unused) and 8 for ra
  and s0

  4000f4:       afbf0014        sw      ra,20(sp)
  Save the return address for the function on the stack. This
  function calls other functions, which means the ra register will be
  overwritten.
  
  4000f8:       afb00010        sw      s0,16(sp)
  Recall the 's' registers must be preserved when we return from this
  function. We only use s0, so save it on the stack so we can use the
  register in this function, but restore it before returning.

  4000fc:       80820000        lb      v0,0(a0)
  Load a character from the pointer passed as the first argument.
  
  400100:       00000000        nop
  nop

  400104:       10400007        beqz    v0,400124 <reverse_print+0x34>
  Test is the character is zero, if so, jump forward to 400124

  400108:       00808021        move    s0,a0
  This is on the delay slot, save the pointer in s0

  40010c:       0c10003c        jal     4000f0 <reverse_print>
  Call reverse print
  
  400110:       24840001        addiu   a0,a0,1
  This is in the delay slot, add 1 to the pointer to have reverse
  print start on the next character in the string.

  400114:       24040001        li      a0,1
  Load the file descriptor for write (1).

  400118:       02002821        move    a1,s0
  Remember s0 is preserved across function calls above, so s0 still
  contains the original pointer passed into the function. Pass the
  pointer to write.
  
  40011c:       0c1000af        jal     4002bc <write>
  Call write function

  400120:       24060001        li      a2,1
  Another delay slot, load the number of bytes write should output (1 byte).

  400124:       8fbf0014        lw      ra,20(sp)
  Restore the return address of this function in prep for return from
  function
  
  400128:       8fb00010        lw      s0,16(sp)
  Restore s0 to whatever it was before this function was called.

  40012c:       03e00008        jr      ra
  Return to the caller.

  400130:       27bd0018        addiu   sp,sp,24
  In the branch delay slot, deallocate the stack.
```

  b. What is the maximum depth the stack can grow to when this function is called?  
  the length of the string + 1
  The stack of each invocation of `reverse_print` is 24 bytes, but the function is recursive. The allocation is 24 bytes x the length of the string. If the string is unbounded, the recursion is too, and the stack growth is unbounded.

Q4. Why is recursion or large arrays of local variables avoided by kernel programmers?

Because there's not enough space on the stack. The kernel stack is usually a limited resource. A stack overflow crashes the entire machine.

### Threads

Q5. Compare cooperative versus preemptive multithreading?

Cooperative multithreading is where the running thread must explicitly `yield()` the CPU so that the dispatcher can select a ready thread to run next.  
Preemptive multithreading is where an external event (e.g. a regular timer interrupt) causes the dispatcher to be invoked and **preempt** the running thread and select a ready thread to run next.

Cooperative multithreading relies on the cooperation of the threads to ensure each thread receives regular CPU time.  
Preemptive multithreading enforces regular (at least systematic) allocation of CPU time to each thread even when a thread is uncooperative or malicious.

Q6. Describe user-level threads and kernel-level threads. What are the advantages or disadvantages of each approach?

User-level threads are managed by the application. The OS only sees one thread, when there are multiple threads running
If one thread blocks, all the other application threads block
Much quicker to switch then kernel-level threads

Kernel-level is managed by the OS
Slower to switch threads

Q7. A web server is constructed such that it is multithreaded. If the only way to read from a file is a normal blocking read system call, do you think user-level threads or kernel-level threads are being used for the web server? Why?

Q8. Assume a multi-process operating system with single-threaded applications. The OS manages the concurrent application requests by having a thread of control within the kernel for each process. Such a OS would have an in-kernel stack associated with each process.

Switching between each process (in-kernel thread) is performed by the function switch_thread(cur_tcb,dst_tcb). What does this function do?

Switches from thread cur_tcb to dst_tcb

### Kernel Entry and Exit

Q9. What is the EPC register? What is it used for?

Exception program counter; stores the instruction that caused the exception. Used for the OS to resolve exceptions.

Q10. What happens to the KUc and IEc bits in the STATUS register when an exception occurs? Why? How are they restored?

KUc stores the flag for whether we are running in kernel-mode or user-mode
IEc stores the flag for whether interrupts are disabled or not

Restored  by just shifting back

Q11. What is the value of ExcCode in the Cause register immediately after a system call exception occurs?

8

Q12. Why must kernel programmers be especially careful when implementing system calls?

1. a mistake in kernel-mode will crash the entire OS
2. security - you have access to everything; if you dont check arguments properly you computer may be compromised

Q13. The following questions are focused on the case study of the system call convention used by OS/161 on the MIPS R3000 from the lecture slides.

  a. How does the 'C' function calling convention relate to the system call interface between the application and the kernel?
  b. What does the most work to preserve the compiler calling convention, the system call wrapper, or the OS/161 kernel.
  The kernel because the system call wrapper simply passes the arguments
  c. At minimum, what additional information is required beyond that passed to the system-call wrapper function?
  The system call code to be executed

Q14. In the example given in lectures, the library function read invoked the read system call. Is it essential that both have the same name? If not, which name is important?

No. The important name is the library function name.

Q15. To a programmer, a system call looks like any other call to a library function. Is it important that a programmer know which library function result in system calls? Under what circumstances and why?

From a correctness perspective, we don't care about the difference.
If we care about performance, we will care because system calls takes longer considering the context switching required

Q16. Describe a plausible sequence of activities that occur when a timer interrupt results in a context switch.

Page last modified: 4:38pm on Thursday, 5th of March, 2020
